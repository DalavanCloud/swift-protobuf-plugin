# API Overview

This is a description of how you can use the code generated by the plugin.

Apart from the actual properties themselves, most of this is not explicit in the generated code.  Rather, most of this appears in common shared protocols in the runtime library.  They're collected here to present a single document for how you can use the generated code.

## Message API

Messages in the input proto file generate Swift structs in the result.  These structs conform to `ProtobufMessage` and provide Swift properties for every field, basic information about the message, standard initializers, and serialization and deserialization methods.

Here is a simple proto3 input file to motivate the example below:

```
syntax = "proto3";
message Example {
   enum E {
      DEFAULT = 0;
   }
   int32 field1 = 1;
   repeated string field2 = 2;
}
```

Here is the API for the struct generated from the above.  Note that this includes a lot of methods that come from various protocols and omits some parts of the generated code that are intended purely for internal use by the library:

```
public struct Example: ProtobufMessage {
  // The generated struct carries constant properties reflecting
  // basic information about the message:
  public var swiftClassName: String {return "Example"}
  public var protoMessageName: String {return "Example"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return ["field": 1]}
  public var protoFieldNames: [String: Int] {return ["field": 1]}

  // Nested enum and message types are nested in the generated Swift
  public enum E: ProtobufEnum { ... }

  // A public property is created for each field in the proto.
  public var field1: Int32 { get set }
  public var field2: [String] { get set }

  // Default Initializer
  public init()

  // A convenience initializer is constructed that has an
  // argument for every field.  This simplifies constructing
  // complex constant objects.
  public init(field1: Int32? = nil, field2: [String] = [])

  // Messages can be serialized or deserialized to Data objects
  // using protobuf binary format.
  // The extension set methods are only for proto2 extensible messages;
  // see below for more details.
  func serializeProtobuf() throws -> Data
  init(protobuf: Data) throws {
  init(protobuf: Data, extensions: ProtobufExtensionSet? = nil) throws

  // Messages can be serialized or deserialized to String objects
  // using JSON format.
  // See below for discussion of extension sets.
  func serializeJSON() throws -> String
  init(json: String) throws
  init(json: String, extensions: ProtobufExtensionSet) throws

  public var debugDescription: String
  public var hashValue: Int

  // Returns true if none of the fields are set to non-default values.
  public var isEmpty: Bool

  // The == operator below is implemented in terms of this method
  // so that you can easily override the implementation.
  // You should not call this method directly.
  public var isEqual(other: Example) -> Bool

  // These are the core methods used by all serialization and
  // deserialization mechanisms.
  public func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool
  public func traverse(visitor: inout ProtobufVisitor) throws
}

func ==(lhs: Example, rhs: Example) -> Bool
```

### Overridable Message methods

The following methods can be defined in manually-constructed extensions if you want to override the generated behavior for any reason:

```
   // These are standard properties.
   public var debugDescription: String
   public var hashValue: Int
   public var isEmpty: Bool

   // These are heavily used by the protobuf libraries but are rarely
   // used directly in normal code.
   public func isEqualTo(other: Example) -> Bool
   public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool
   public func traverse(visitor: inout ProtobufVisitor) throws
```

To allow the above to be easily overridden, they are all defined
in the `ProtobufGeneratedMessage` protocol.  The generated code
provides standard implementations of the core capabilities under
different names; you can use these when overriding the above
methods, but we strongly advise you not to call these directly
from your own code except in such overrides:

```
public extension Example: ProtobufGeneratedMessage {
  public mutating fund _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool
  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws
  public var _protoc_generated_isEmpty: Bool
  public var _protoc_generated_isEqualTo(other: Example) -> Bool
}
```

## Enum API

Proto enums are translated to Swift enums in a fairly straightforward manner.  The resulting Swift enums conform to the `ProtobufEnum` protocol which extends `RawRepresentable` with a `RawValue` of `Int`.

Proto2 enums simply have a case for each enum value.  If deserialization encounters an unknown value, that value is either ignored (JSON) or handled as an unknown field (protobuf binary), depending on the particular serialization.

Proto3 enums have an additional `UNRECOGNIZED(Int)` case that is used whenever an unrecognized value is parsed from protobuf serialization or from other serializations that store integer enum values.  JSON serialization with named enum values drops unrecognize names.

```
public enum MyEnum: ProtobufEnum {
    public typealias RawValue = Int

    // Case for each value
    // Names are translated to a lowerCamelCase convention from
    // the UPPER_CASE convention in the proto file:
    case default
    case other
    case andMore
    case UNRECOGNIZED(Int) // Only in proto3 enums

    // Initializer selects the default value (see proto2 and proto3
    // language guides for details.
    public init()

    public init?(rawValue: Int)
    public init?(name: String)
    // Select the enum case based on JSON serialized name.
    // (See proto3 JSON serialization specification for details)
    public init?(jsonName: String)
    // Select the enum case matching the provide name, as
    // specified in the proto file.
    public init?(protoName: String)
    public var rawValue: Int
    // Return the full JSON coding for the current value.
    // This is normally a quoted string, but
    // UNRECOGNIZED(Int) returns a JSON number.
    public var json: String
    public var hashValue: Int
    public var debugDescription: String
}
```

## Mapping proto field types to Swift types

Types in the proto file are mapped to Swift types as follows:

### Basic types

| Proto type                |  Swift Type        |
| ------------------------- | ------------------ |
| int32                     | Int32              |
| sint32                    | Int32              |
| sfixed32                  | Int32              |
| uint32                    | UInt32             |
| fixed32                   | UInt32             |
| int64                     | Int64              |
| sint64                    | Int64              |
| sfixed64                  | Int64              |
| uint64                    | UInt64             |
| fixed64                   | UInt64             |
| bool                      | Bool               |
| float                     | Float              |
| double                    | Double             |
| string                    | String             |
| bytes                     | Data               |

### Generated Types

Enums in the proto file generate Int-valued enums in the Swift code.

Groups in the proto file generate Swift structs that conform to ProtobufGroup.

Messages in the proto file generate Swift structs that conform to ProtobufMessage.

Note:  There are also `ProtobufGeneratedGroup` and `ProtobufGeneratedMessage` protocols.  You should not refer to these directly; use `ProtobufGroup` and `ProtobufMessage` when you need to work with arbitrary groups or messages.

### Type modifiers

**Proto3 singular fields** generate properties of the corresponding type above.  These properties are initialized to the appropriate default value as specified in the proto3 documentation:

* Numeric fields are initialized to zero.
* Boolean fields are initialize to false.
* String fields are initialized to the empty string.
* Bytes fields are initialized to an empty Data() object.
* Enum fields are initialized to the default value (the value corresponding to zero, which must be the first item in the enum).
* Message fields are initialized to an empty message of the appropriate type.

Notes: For performance, the field may be initialized lazily, but this is invisible to the user.  The property will be serialized if it has a non-default value.

**Proto2 `optional` fields without default values** generate properties whose type is `Optional<T>` for the corresponding T as listed above.  The initial value is nil.  You can set the value to nil to erase it.

**Proto2 `optional` fields with default values** work the same way but when read, `nil` values are converted to the default value.  In particular, setting the value to nil restores the default.  Optional fields are serialized unless the internal value is nil, so setting an optional field explicitly to the default value will cause it to be serialized.

**Proto2 `required` fields** TODO

### Compound types

**Proto `repeated` fields** generate simple properties of type `Array<T>` where T is the base type from above.  Repeated fields are always initialized to empty.

**Proto `map` fields** generate simple properties of type `Dictionary<T,U>` where T and U are the respective key and value types from above.  Map fields are always initialized to an empty map.

### Oneof fields

Oneof fields generate an enum with a case for each associated field plus a separate `None` case.  These enums conform to `ProtobufOneofEnum`.  Every case except for the `None` case has an associated value corresponding to the declared field.

In addition to the enum itself, the message will contain a read/write property named after the enum which contains the enum value and a separate read/write computed property for each member field of the enum.

### Groups

Groups act exactly like messages in all respects, except that they cannot be directly serialized on their own and they conform to the `ProtobufGroup` protocol instead of `ProtobufMessage`.

## Well-Known Types

For most of the proto3 well-known types, the Swift API is exactly what you would expect from the corresponding proto definitions.  (In fact, the runtime library version for most of these is simply generated.)  The variations are described below.

| Proto Type                  |  Swift Type               |
| -------------------------   | -----------------------   |
| google.protobuf.Any         | Google_Protobuf_Any         |
| google.protobuf.Api         | Google_Protobuf_Api         |
| google.protobuf.BoolValue   | Google_Protobuf_BoolValue   |
| google.protobuf.BytesValue  | Google_Protobuf_BytesValue  |
| google.protobuf.DoubleValue | Google_Protobuf_DoubleValue |
| google.protobuf.Duration    | Google_Protobuf_Duration    |
| google.protobuf.Empty       | Google_Protobuf_Empty       |
| google.protobuf.FieldMask   | Google_Protobuf_FieldMask   |
| google.protobuf.FloatValue  | Google_Protobuf_FloatValue  |
| google.protobuf.Int64Value  | Google_Protobuf_Int64Value  |
| google.protobuf.ListValue   | Google_Protobuf_ListValue   |
| google.protobuf.StringValue | Google_Protobuf_StringValue |
| google.protobuf.Struct      | Google_Protobuf_Struct      |
| google.protobuf.Timestamp   | Google_Protobuf_Timestamp   |
| google.protobuf.Type        | Google_Protobuf_Type        |
| google.protobuf.UInt32Value | Google_Protobuf_UInt32Value |
| google.protobuf.UInt64Value | Google_Protobuf_UInt64Value |
| google.protobuf.Value       | Google_Protobuf_Value       |


### Google_Protobuf_Any

The Any JSON representation is treated essentially as a separate serialization format.  Each message has
```
  TODO
```

### Google_Protobuf_BoolValue, Google_Protobuf_BytesValue, etc.

These are customized to produce the expected JSON and Any JSON forms, but are otherwise exactly as you would expect.

### Google_Protobuf_Duration, Google_Protobuf_Timestamp

The `Google_Protobuf_Duration` and `Google_Protobuf_Timestamp` structs have customized JSON and Any JSON handling to match Google's specification.  In particular, JSON serialization will throw an error if the duration is greater than 315576000000 seconds or if the timestamp is before `0001-01-01T00:00:00Z` or after `9999-12-31T23:59:59.999999999Z` Gregorian proleptic.

The `Google_Protobuf_Duration` type also conforms to `ExpressibleByFloatLiteral`; it can be initialized with a double representing the number of seconds.

There are also overrides for simple arithmetic with durations and timestamps:

```
func -(lhs: Google_Protobuf_Timestamp, rhs: Google_Protobuf_Timestamp) -> Google_Protobuf_Duration
func -(lhs: Google_Protobuf_Duration, rhs: Google_Protobuf_Duration) -> Google_Protobuf_Duration
public func +(lhs: Google_Protobuf_Duration, rhs: Google_Protobuf_Duration) -> Google_Protobuf_Duration
public func -(operand: Google_Protobuf_Duration) -> Google_Protobuf_Duration
public func -(lhs: Google_Protobuf_Timestamp, rhs: Google_Protobuf_Duration) -> Google_Protobuf_Timestamp
public func +(lhs: Google_Protobuf_Timestamp, rhs: Google_Protobuf_Duration) -> Google_Protobuf_Timestamp
```

### Google_Protobuf_Value, Google_Protobuf_Struct, Google_Protobuf_ArrayValue

`Google_Protobuf_NullValue` is a simple single-value enum.

As expected, `Google_Protobuf_Struct` contains a single `fields` dictionary mapping strings to `Google_Protobuf_Value` objects.  It also conforms to `ExpressibleByDictionaryLiteral` and provides a `subscript` for directly accessing the values by name.

The `Google_Protobuf_Value` type implements the expected oneof semantics, with a separate property for each type of contained object.

## Extensions

Extensions are used to add additional properties to messages defined elsewhere.  They are fully supported in proto2 files.  They are supported in proto3 only when extending the standard Descriptor type.  These are defined in proto files as follows:

```
/// File sample.proto
syntax="proto2";
message CanBeExtended {
   extensions 100 to 200;
}

extend CanBeExtended {
   optional int32 extensionField = 100;
}
```

There are several pieces to the extension support:

 * **Extensible Messages** (such as `CanBeExtended` above) conform to `ProtobufExtensibleMessage` and define some additional methods needed by the other components.  You should not use these methods directly.
 * **Extension properties** use Swift `extension` to add new properties to the original message.  In many cases, you can simply use the extension properties without understanding any of the other extension machinery.  The above example defines a new property `CanBeExtended.extensionField` of type `Optional<Int32>`.
 * **Extension objects** are opaque objects that define the extension itself and its storage.  Because proto allows extension names to be reused, these objects appear in the context corresponding to the context where the proto extension was defined, which generally does not correspond to that of the message being extended.  In the above example, the extension object would be `CanBeExtended_extensionField`.
 * **Extension sets** are collections of extension objects.  An extension set is generated by the code generator and included as a static global variable in every Swift source file generated from a proto file that defines extensions.  Extension sets are provided to the deserialization APIs to define what extension fields the decoder should recognize.  In the above example, the generated extension set would be `Sample_Extensions`.

```
/// ProtobufExtensionSet implements a subset of the Set API.
public struct ProtobufExtensionSet: ExpressibleByArrayLiteral {
    public typealias Element = ProtobufMessageExtension
    public init()
    init(arrayLiteral: Element...)
    public subscript(messageType: ProtobufMessage.Type, protoFieldNumber: Int) -> ProtobufMessageExtension?
    public func fieldNumberForJson(messageType: ProtobufJSONMessageBase.Type, jsonFieldName: String) -> Int?
    public mutating func insert(_: Element)
    public mutating func insert(contentsOf: [Element])
    public mutating func union(_: ProtobufExtensionSet) -> ProtobufExtensionSet
}
```
